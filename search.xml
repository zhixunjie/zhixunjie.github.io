<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线程同步黑魔法]]></title>
    <url>%2Fposts%2F2163080963%2F</url>
    <content type="text"><![CDATA[线程同步的方法 apue 11.6 原子操作。防止race condition的出现。 互斥量、互斥锁。对race conditon加锁。 读写锁。相对于互斥量，读操作会有更高的并发量，写操作原理等同于互斥量。 条件变量。配合互斥量一起使用，适用于需要达到某个条件就处理某件事情的场景。 自旋锁。作用与互斥量相同。不常用，自旋锁需要处于忙等待的状态，CPU资源一直被线程占用。 屏障。适用于多个线程配合完成一件事情的场景。 使用互斥量时，避免死锁的方法 apue 11.6.2 每个加锁的地方都使用相同的顺序加锁。防止ABBA导致的死锁。 同一线程不能对同一互斥量加锁两次。调用两次pthread_mutex_lock函数试试咯。 尝试获得锁，获取不到则回滚。使用pthread_mutex_trylock函数。 使用带有超时时间的锁。使用pthread_mutex_timedlock函数。]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进程和线程的资源共享]]></title>
    <url>%2Fposts%2F2322051207%2F</url>
    <content type="text"><![CDATA[参考 apue8.3、11.2 父进程的资源共享 不同进程使用不同的地址空间，它们的内存是独立的。 子进程在父进程fork以后，将会复制一份跟父进程一样的地址空间，它们的内存是独立的。 父子进程的fd相当于dup(父进程的fd)。 线程的资源共享 进程中的所有线程共享同一进程的内存，包括：全局内存、堆内存、栈内存，还有文件描述符。 每个线程会有各自的errno。 每个线程会有各自的私有数据。]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二进制日志、重做日志]]></title>
    <url>%2Fposts%2F1195869926%2F</url>
    <content type="text"><![CDATA[重做日志(redo log) 《极客时间-MySQL实战45讲》 02 《MySQL技术内幕 InnoDB存储引擎》2.4(checkpoint)、3.6.2、7.2.1 https://dev.mysql.com/doc/refman/5.7/en/innodb-redo-log.html 原理： https://mp.weixin.qq.com/s/vdcO_PIfdjtfXzJkw4Tzmw https://mp.weixin.qq.com/s/myd5A_UQOZBlkpdfPpUB6w 当数据更新时，innodb引擎会先更新数据写入内存，然后把更新动作写入redo log，过一段时间再统一把在内存中的修改刷新到磁盘。这个机制叫做WAL(write ahead logging)。 如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。有了redo log的记录，就可以定期把内存中的数据刷到磁盘。这个过程也叫刷脏数据，就是把没保存到磁盘的内存数据保存到磁盘中的过程。 重做的作用 结合checkpoint刷脏数据。 保证crash-safe。 二进制日志(binary log) 《极客时间-MySQL实战45讲》 02 《MySQL技术内幕 InnoDB存储引擎》3.2.4 二进制日志记录了数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改。然而，若更改操作本身并没有导致数据库发生变化，那么该操作可能也会写入二进制日志。如： 123mysql&gt; UPDATE t SET a=1 WHERE a=2;Query OK,0 rows affected(0.00 sec)Rows matched:0 Changed:0 Warnings:0 二进制日志配置MySQL版本：MySQL 5.6、5.7 123456user=mysqlserver_id = 1log_bin = /var/lib/mysql/log/binary.log #二进制日志,# mkdir /var/lib/mysql/log &amp;&amp; chown mysql:mysql /var/lib/mysql/log其他配置：max_binlog_size 指定了单个二进制日志文件的最大值。如果日志文件大小超过该值，则产生新的二进制日志文件，后缀名+1，并记录到.index文件。 查看二进制文件ll /var/lib/mysql/log/binary*文件binary.index用于记录二进制文件的文件名(vim查看)。文件binary.000001、binary.000002用于记录二进制数据。 二进制日志的作用 恢复(recovery)。某些数据的恢复需要二进制日志。使用数据库全备份+binary log可以把数据库恢复到某一天某一秒的数据。 复制(replication)。其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为slave或standby）与一台MySQL数据库（一般称为master或primary）进行实时同步。 审计(audit)。用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击。 常用操作 查看log_bin相关值。 1mysql&gt; show variables like &apos;%%log_bin%&apos;; 查看当前使用的二进制日志。 1mysql&gt; show master status; 查找当前生成的二进制日志。 12mysql&gt; show binary logs;mysql&gt; show master logs; 查看某个二进制日志内容。 1mysqlbinlog binary.000001 使用新的binlog日志。 123方法一：mysqladmin -uroot -p flush-logs方法二：执行mysql&gt; flush logs;方法三：重启mysqld。systemctrl restart mysqld 清理二进制日志 1mysql&gt; purge binary logs to &apos;binary.000002&apos;; //把binary.000002之前的日志都清除掉 重做日志和二进制日志的区别 redo log 是 InnoDB 引擎特有的；binlog是 MySQL 的 Server 层实现的，所有引擎都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 redo log用于保证crash-safe，binlog用于“归档”数据，恢复数据库数据。 重做日志和二进制日志的写入流程 两阶段提交 写入redo log，redo log进入prepare状态。 写入binlog。 写入binlog后提交事务，redo log变为commit状态。 innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log都直接持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。 sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数也建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。这两个参数不设置1时，日志会先写入到缓冲区。 崩溃恢复3个阶段中，如果在阶段2之前奔溃，重启后，发现binlog没有写入，事务回滚。binlog和redo log保持一致。如果在阶段3之前崩溃，重启后，虽然没有commit，但满足prepare和binlog完整，所以重启后会自动commit。binlog和redolog保持一致。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysqldump]]></title>
    <url>%2Fposts%2F3744389185%2F</url>
    <content type="text"><![CDATA[mysqldump https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html 筛选选项（Filtering Options）--databases：指定导出某个数据库，如 –databases db1 db2 db3--no-data：不导出数据，只导出表结构--ignore-table：忽略某些表，如：–ignore-table=test.user，忽略test数据库的user表 复制时创建备份数据https://dev.mysql.com/doc/refman/5.7/en/replication-gtids-failover.html#replication-gtids-failover-copy --master-data：导出结果对change master语句的处理。默认值为1。当等于1时，change master语句不是注释。适合binary log file postion的复制。当等于2时，change master语句是注释。适合gtid的复制。 如：mysql&gt; mysqldump --databases test **--master-data=1** --host=127.0.0.1 --port=3307 &gt; dbdump.dbmysqldump --databases test **--master-data=2** --host=127.0.0.1 --port=3307 &gt; dbdump.db --set-gtid-purged：导出结果是否包含SET @@GLOBAL.GTID_PURGED语句。 指定该参数等于auto后，在GTID的复制模式下，会导出两个SQL语句： 123456SET @@GLOBAL.GTID_PURGED=&apos;face0627-ed17-11e6-a06e-000c298b2485:1-2&apos;;SET @@SESSION.SQL_LOG_BIN= 0;第一句SQL：表示丢弃事务1~2，并设置gtid_executed的值等于face0627-ed17-11e6-a06e-000c298b2485:1-2。因为mysqldump导出的备份文件恢复的数据其实就是事务1~2的数据，如果slave再次收到master发过来要求执行1~2的事务请求，都会被slave忽略。第二句SQL：表示本次session的操作都不会记录到二进制日志。 –lock-all-tables 和 –single-transaction12345678--single-transaction 导出时启用事务，利用MVCC机制，在RR隔离级别下，复制出来的数据是某一事务版本的数据。适用于支持事务的存储引擎，如：innodb--lock-all-tables 导出时加全局锁，所有数据库都变为只读状态。适用于不支持事务的存储引擎，如：myisam mysqldump --lock-all-tables xxxx相当于mysql&gt; flush tables with read lock;#全局锁(FTWRL),执行命令后所有库所有表都只能读不能写mysql&gt; mysqldump xxxxmysql&gt; unlock tables; 总结1234567当使用二进制日志文件位置的复制，创建备份使用如下sql：mysqldump --lock-all-tables --all-databases --master-data=1 --host=127.0.0.1 --port=3307 &gt; dbdump.sql当使用gtid复制，创建备份使用如下sql：mysqldump --lock-all-tables --all-databases --master-data=2 --set-gtid-purged=auto --host=127.0.0.1 --port=3307 &gt; dbdump.sql如果备份的数据库存储引擎都是innodb，则把--lock-all-tables参数替换为--single-transaction参数，--lock-all-tables使用了全局锁对业务影响太大了。 普通的导入导出数据库12mysqldump --databases wordpress &gt; wordpress.sql -uroot -p //导出数据库mysql &lt; wordpress.sql -uroot -p /导入数据库 FAQ 报错Access denied for user ‘dbuser‘@’localhost’ to database ‘db’ when using LOCK TABLES 原因：该用户无lock tables 该权限处理办法： 给用户赋予lock tables权限。 加上–skip-lock-tables。mysqldump -udbuser -p dbname –skip-lock-tables &gt; dbname.sql 使用root账户执行命令。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[标准IO]]></title>
    <url>%2Fposts%2F3596160467%2F</url>
    <content type="text"><![CDATA[参考 《C和指针》第15章 apue 第5章 Input/Output on Streams 低级IO与标准IO的区别？fopen /open，read/write和fread/fwrite区别 标准IO：标准IO函数是对低级IO函数的进一步封装(可以通过strace验证)。低级IO：低级IO函数属于底层函数，可以做更多底层的操作，但是很多东西需要规范(标准IO做的事情，如：引入标准IO缓存区)。 1234567// 标准IO函数的对应的底层IO操作。// =&gt;表示对应关系fgetc =&gt; readfgets =&gt; readfputc =&gt; writefputs =&gt; write 流（Stream） 《c和指针》15.4 apue 5.2 https://www.gnu.org/software/libc/manual/html_node/Streams.html 流是什么流的概念感觉太抽象了。一时半刻也不需要深入理解是什么意思。 可以把流看成是FILE结构。通过不同的流(FILE)，进行字符、字符串、文件的输入/输出。 流相当于水管，用于输入/输出数据。 绝大多数的流会加上缓冲区这个东西，用于解决读写速度不一致的问题以及减少硬盘读写次数。 流的分类 用于输入的流叫输入流。 用于输出的流叫输出流。 用于文件操作的流叫文件流。 文本流(text)，如：scanf、getc、gets那些函数就属于文本流操作，以字符为单位去传输数据。 二进制流(binary)，如：fread、fwrite函数就属于二进制流操作，以字节为单位去传输数据。 流对象-FILEFILE是一个数据结构(struct实现)，用于访问一个流。如果同时打开了多个流，每个流都有一个相应的FILE与它关联。 标准IO通过FILE流对象进行各种的文件操作。 如：通过fopen函数打开某个文件并获取到一个FILE指针，之后的各种文件操作函数都需要使用FILE指针。 1234567891011121314151617181920212223&gt; #include &lt;stdio.h&gt;&gt; #include &lt;stdlib.h&gt;&gt; &gt; int main(void) &#123;&gt; FILE *fp = fopen("test.txt", "r");&gt; if (!fp) &#123;&gt; perror("File opening failed");&gt; return EXIT_FAILURE;&gt; &#125;&gt; &gt; int c;&gt; while ((c = fgetc(fp)) != EOF) &#123;&gt; putchar(c);&gt; &#125;&gt; &gt; if (ferror(fp))&gt; puts("I/O error when reading");&gt; else if (feof(fp))&gt; puts("End of file reached successfully");&gt; &gt; fclose(fp);&gt; &#125;&gt; 标准输入、标准输出、标准错误对应的FILE宏：stdin、stdout、stderr C程序规定在运行时必须提供至少三个流，它们分别是stdin、stdout、stderr，它们都是FILE指针类型的宏。分别对应的是linux系统的标准输入/标准输出/标准错误。所谓的这些标准输入，标准输出，标准错误，其实就是打开了3个文件分别处理这些标准输入、标准输出、错误输出。本质上也是文件操作。 函数fwide改变流的定向。流的定向决定了所读、写的字符是单字节还是宽字节。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;errno.h&gt;int main()&#123; int result; FILE *fp; char *filePath = "../files/a.txt"; fp = fopen(filePath, "r"); /** * mode * 等于负值,指向字节定向 * 等于正值,指向宽定向 * 等于0,不设置,返回当前流定向 * * 返回值 * 等于负值,指向字节定向 * 等于正值,指向宽定向 * 等于0,未定向 * */// result = fwide(fp, -1);// result = fwide(fp, 1);// result = fwide(fp, 0); printf("%d\n", result); if (errno) &#123; perror("error"); &#125; return 0;&#125; 函数filenoint fileno(FILE * fp) 获取FILE对象的fd。 函数ferror、feof、clearerr apue 5.6 123int ferror( FILE *stream );int feof( FILE *stream );void clearerr( FILE *stream ); 函数ferror 用于判断文件操作是否发生错误。 函数feof 用于判断是否到达文件尾部。 两个函数返回非0表示真，返回0表示假。每个FILE对象维护了两个标志：出错标志和文件结束标志。函数ferror和feof返回的就是这两个标志的值。 函数clearerr 用于清除FILE对象维护的出错标志和文件结束标志。 ferror、feof的应用： 1234567891011121314151617181920212223242526272829&gt; #include &lt;stdio.h&gt;&gt; #include &lt;stdlib.h&gt;&gt; #include &lt;string.h&gt;&gt; &gt; int main()&gt; &#123;&gt; int result;&gt; FILE *fp;&gt; char *filePath = "../files/a.txt";&gt; &gt; fp = fopen(filePath, "r");&gt; if (!fp) &#123;&gt; perror("文件打开错误");&gt; exit(1);&gt; &#125;&gt; &gt; while ((result = getc(fp)) != EOF) &#123;&gt; printf("%c\n", (char) result);&gt; &#125;&gt; &gt; if (ferror(fp)) &#123;&gt; puts("IO error when reading");&gt; &#125; else if (feof(fp)) &#123;&gt; puts("end of file reached successfully");&gt; &#125;&gt; &gt; return 0;&gt; &#125;&gt; 标准IO缓冲区 《c和指针》15.4 apue 5.4、5.12 标准IO缓冲区的目的是尽可能减少使用read和write调用的次数(减少系统调用次数)。 标准IO缓冲区的默认大小为4096字节，调用fread 函数时，只有缓冲区的大小到达4096字节，才进行一次系统调用read函数的操作。 缓冲区分为输入缓冲区、输出缓冲区。 标准I/O的所有函数都是带标准IO缓冲区的。 缓冲区类型 以下提及的实际IO操作、真正的IO操作指的是系统调用IO操作。 全缓冲。 在这种情况下，当填满标准I/O缓存后才进行实际I/O操作。通常情况下，磁盘文件实施全缓冲。如：文件使用fwrite函数不断向缓冲区写数据，当缓冲区满了以后，才调用系统调用函数write把数据写入到磁盘。 行缓冲。 在这种情况下，当在输入和输出中遇到换行符时才执行真正的I/O操作。通常情况下，涉及终端时使用行缓冲。如:标准输入和标准输出 不带缓冲。 标准错误stderr就不带缓冲，错误信息需要直接尽快地显示出来。 缓冲区的刷新时机 缓冲区满(全缓冲)。 遇到换行(行缓冲)。 调用fflush函数刷新缓冲区。 关闭文件。调用close函数。 进程结束。exit终止或main函数返回。 函数setbuf、setvbuf 设置缓冲区。 设置包括：缓冲区变量、缓冲区类型、缓冲区大小。 1234567891011121314151617#include &lt;stdio.h&gt; int main() &#123; char *filePath = "../files/a.txt"; FILE *fp = fopen(filePath, "w+"); int n = 4; char buf[n]; setbuf(fp, NULL);//关闭缓冲 // setvbuf(fp, buf, _IOFBF, n); // 设置长度为n的用户缓冲区buf // setvbuf(fp, NULL, _IOFBF, n); // 设置合适长度的系统缓冲区buf printf("缓冲区大小为%d字节\n", fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base); return 0; &#125; 函数fflushint fflush( FILE *stream ); 刷新缓冲区。 冲刷的对象是输出缓冲区，跟输入缓冲区没有关系的。 正常情况下，对于写入操作（fputs、fwrite等），会先把数据写入到输出流缓冲区。当缓冲区满了，才把数据写入到文件。调用此函数后不管输出缓冲区是否已满，都必须冲刷缓冲区，强制把缓冲区的内容写入到文件。 当参数为NULL时，刷新所有输出流(所有的FILE对象)。 测试标准IO缓冲区12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 研究标准IO缓冲区 * 测试命令： * strace -s 1024 ./main.out * ./5-11-buf.out &lt; /etc/group &gt; std.out 2&gt; std.err */#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;#include &lt;string.h&gt;#include &lt;zconf.h&gt;int is_unbuffered(FILE *fp)&#123; return (fp-&gt;_flags &amp; _IO_UNBUFFERED);&#125;int is_linebuffered(FILE *fp)&#123; return (fp-&gt;_flags &amp; _IO_LINE_BUF);&#125;int buffer_size(FILE *fp)&#123; return (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);&#125;void pr_stdio(const char *name, FILE *fp)&#123; printf("stream = %s, ", name); if (is_unbuffered(fp)) printf("unbuffered"); else if (is_linebuffered(fp)) printf("line buffered"); else /* if neither of above */ printf("fully buffered"); printf(", buffer size = %d\n", buffer_size(fp));&#125;int main()&#123; char tmp[20]; int nSetbuf = 4; char setbuf[nSetbuf]; char *filePath = "../files/a.txt"; int count = 3; char *buf = "Hello world"; //测试文件的缓冲区 FILE *fp = fopen(filePath, "w+");// setvbuf(fp, setbuf, _IOFBF, (size_t)nSetbuf);//设置IO缓冲区// pr_stdio("file", fp); while (count--) &#123; sprintf(tmp, "%s%d\n", buf, count); fwrite(tmp, sizeof(char), strlen(tmp), fp);// if (count == 1) &#123;// fflush(fp);// &#125; sleep(2); &#125;// pr_stdio("stdin", stdin);// pr_stdio("stdout", stdout);// pr_stdio("stderr", stderr);// fp = fopen("/etc/passwd", "r");// pr_stdio("/etc/passwd", fp); return 0;&#125; 函数fopen打开流。打开文件并返回FILE指针。12345678910#include &lt;stdio.h&gt; int main() &#123; FILE *fp = fopen(&quot;a.txt&quot;, &quot;r&quot;); if (fp == NULL) &#123; printf(&quot;文件打开失败&quot;); &#125; else &#123; printf(&quot;文件打开成功&quot;); &#125; &#125; mode 参数(参数2)，设置打开模式。 1234567891011&gt; r 用于读取操作。文件存在从头读，文件不存在则打开失败。&gt; w 用于写入操作。文件不存在则创建，截断内容。&gt; a 用于写入操作。文件不存在则创建，添加内容。&gt; &gt; r+ r的扩展版。可读写，文件不存在则打开失败。&gt; w+ w的扩展版。可读写，文件不存在则创建，截断内容。&gt; a+ a的扩展版。可读写，文件不存在则创建，添加内容。&gt; &gt; b 以二进制模式打开&gt; 与b组合使用：rb、wb、ab、r+b、w+b、a+b&gt; 函数fclose关闭流。 执行成功返回0，否则返回-1。 关闭文件之前，需要先刷新缓冲区(函数fflush的行为)。 二进制流函数freadsize_t fread( void*buffer, size_t size, size_t count, FILE *stream ); 参数size指的是buf参数中单个元素大小(字节数)。 参数count指读取多少个元素。 相对于函数read，这里读取的是元素的个数，而不是字节数。 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char buf[5]; char *filePath = "../files/a.txt"; FILE *fp = fopen(filePath, "rb"); fread(buf, sizeof(buf[0]), sizeof(buf) / sizeof(buf[0]), fp); printf("%s\n", buf); fclose(fp); return 0;&#125; 函数fwritesize_t fwrite( const void *buffer, size_t size, size_t count,FILE *stream ); 参数size指的是buf参数中单个元素大小(字节数)。 参数count指写入多少个元素。 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char *buf = "hello world"; char *filePath = "../files/a.txt"; FILE *fp = fopen(filePath, "wb"); fwrite(buf, sizeof(char), strlen(buf), fp); printf("%s\n", buf); fclose(fp); return 0;&#125; 文本流(无格式)字符函数getc、fgetc、getchar123int getc(FILE *fp); int fgetc(FILE *fp);int getchar(); 函数getc和函数fgetc，都是从文件流读取字符。 函数getc和函数fgetc的返回值类型是int。返回字符之前，把其unsigned char类型转换为int类型。这样做的原因是为了在读取发生错误或者读取到达文件尾端时返回EOF(-1)。所以说，当返回EOF表示读取发生了错误或者到达文件尾端了。 函数getc通过宏实现，fgetc通过函数实现。因此： getc不应该有宏的副作用，因为它可能会被计算多次。 fgetc是个函数，通过得到其地址，可以把它作为参数传给另一个函数(可以作为回调函数)。 调用宏的性能比调用函数的性能要高，所以getc性能更好。 函数getchar，从标准输入读取字符。等同于getc(stdin)。 getc使用例子： 1234567891011121314151617181920212223242526272829&gt; #include &lt;stdio.h&gt;&gt; #include &lt;stdlib.h&gt;&gt; #include &lt;string.h&gt;&gt; &gt; int main()&gt; &#123;&gt; int result;&gt; FILE *fp;&gt; char *filePath = "../files/a.txt";&gt; &gt; fp = fopen(filePath, "r");&gt; if (!fp) &#123;&gt; perror("文件打开错误");&gt; exit(1);&gt; &#125;&gt; &gt; while ((result = getc(fp)) != EOF) &#123;&gt; printf("%c\n", (char) result);&gt; &#125;&gt; &gt; if (ferror(fp)) &#123;&gt; puts("IO error when reading");&gt; &#125; else if (feof(fp)) &#123;&gt; puts("end of file reached successfully");&gt; &#125;&gt; &gt; return 0;&gt; &#125;&gt; getchar使用例子： 1234567891011&gt; #include &lt;stdio.h&gt;&gt; &gt; int main() &#123;&gt; char ch;&gt; while ((ch = getchar()) != EOF) &#123;&gt; putchar(ch);&gt; &#125;&gt; &gt; return 0;&gt; &#125;&gt; 函数putc、fputc、putchar123int putc(int ch, FILE *fp);int fputc(int ch, FILE *fp);int putchar(int ch); 函数putc和函数fputc，都是把字符输出到文件流。 函数putchar，把字符输出到标准输出。等同于putc(stdout)。 3个函数的使用和区别与getc、fgetc、getchar是一样的。 字符串函数gets、fgets12char *fgets(char *buf, int n, FILE *fp); char *gets(char *buf); 函数fgets，从文件流中读取字符串。 函数fgets需要指定缓冲区长度(读取长度)。 此函数会一直读取，直到遇到换行符或到达指定的读取长度。 读取出来的字符串总是会以null字节结尾(总是会在字符串尾部加上结束符号)。 函数gets，从标准输入流中读取字符串。 函数gets是一个不推荐使用的函数(并且在C11时已被废弃)。 调用者不能指定缓冲区长度，可能会造成缓冲区溢出(读取时一直没遇到换行符导致一直读取)。 读取时不会把换行符读取到缓存区中。 fgets的使用例子： 1234567891011121314151617181920212223242526&gt;#include &lt;stdio.h&gt;&gt;#include &lt;string.h&gt;&gt;#include &lt;stdlib.h&gt;&gt;&gt;int main()&gt;&#123;&gt; int n = 20;&gt; char *buf = malloc(sizeof(char) * n);&gt; FILE *fp = fopen("/etc/passwd", "r");&gt; FILE *dest = fopen("../files/a.txt", "w");&gt;&gt; while (fgets(buf, n, fp) != NULL) &#123;&gt;// fputs(buf, dest);//不会自动加上换行&gt;// fputs(buf, stdout);//不会自动加上换行&gt;// puts(buf);//会自动加上换行&gt; &#125;&gt;&gt; if (ferror(fp)) &#123;&gt; puts("IO error when reading");&gt; &#125; else if (feof(fp)) &#123;&gt; puts("end of file reached successfully");&gt; &#125;&gt;&gt; return 0;&gt;&#125;&gt; 函数puts、fputs12int fputs(const char *str, FILE *stream );int puts(const char *str ); 函数fputs，把字符串输出到文件流。 fputs不会自动加上换行，并忽略结尾的结束符(不会输出结束符)。 函数puts，把字符串输出到标准输出。 puts会自动加上换行，并忽略结尾的结束符(不会输出结束符)。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int n = 20; char *buf = malloc(sizeof(char) * n); FILE *fp = fopen("/etc/passwd", "r"); FILE *dest = fopen("../files/a.txt", "w"); while (fgets(buf, n, fp) != NULL) &#123;// fputs(buf, dest);//不会自动加上换行// fputs(buf, stdout);//不会自动加上换行// puts(buf);//会自动加上换行 &#125; if (ferror(fp)) &#123; puts("IO error when reading"); &#125; else if (feof(fp)) &#123; puts("end of file reached successfully"); &#125; return 0;&#125; 文本流(有格式)scanf家族函数scanf1int scanf(const char *format, ... ); 从标准输入中读取内容。 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int a; char str[20]; scanf("%d", &amp;a);//读取整数 printf("%d\n", a); scanf("%s", str);//读取字符串 printf("%s\n", str); return 0;&#125; 函数fscanf1int fscanf(FILE *stream, const char *format, ... ); 从文件中读取内容。 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; FILE *fp; char *buf = malloc(sizeof(char) * 1000); char *filePath = "../files/a.txt"; fp = fopen(filePath, "r"); fscanf(fp, "%s", buf); printf("%s\n", buf); return 0;&#125; 函数sscanf1int sscanf(const char *buffer, const char *format, ... ); 从字符串中读取内容。 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *src = "hello world"; char *dest = malloc(sizeof(char) * 1000); sscanf(src, "%s", dest); printf("%s\n", dest); return 0;&#125; printf家族格式说明(format)12345678910111213列出常用的%d 输出int值。%u 输出unsigned int值。==========================================%o 输出8进制的无符号值。==========================================%x、%X 输出为16进制格式的无符号值。x采用的是a~f的16进制表示方式，如：0x3a。X采用的是A~F的16进制表示方式，如：0x3A。==========================================%f 输出float值。%.2f 指定输出的位数。小数点后第二位数字会根据第三位数字进行四舍五入。]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>标准IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next标签]]></title>
    <url>%2Fposts%2F556871265%2F</url>
    <content type="text"><![CDATA[引用样式 http://theme-next.iissnan.com/tag-plugins.html https://theme-next.org/docs/tag-plugins/ 内容 内容 内容 内容 内容 内容]]></content>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo图片管理]]></title>
    <url>%2Fposts%2F1036090074%2F</url>
    <content type="text"><![CDATA[本地存储图片使用images文件管理 https://hexo.io/zh-cn/docs/asset-folders.html 123文件存放位置：/blog/source/_posts/Hexo图片管理/1.jpg输入Markdown内容：![我是图片](/images/1.jpg)最终生成的图片链接：http://localhost:4000/images/1.jpg 技巧：在images目录下使用不同的文件夹进行图片分类 使用post_asset_folder属性管理 https://hexo.io/zh-cn/docs/asset-folders.html https://github.com/dangxuandev/hexo-asset-image 123文件存放位置：/blog/source/_posts/Hexo图片管理/1.jpg输入Markdown内容：![我是图片](1.jpg) 或者 Hexo定义的标签：&#123;% asset_img 1.jpg 50 50 我是图片 %&#125; 最终生成的图片链接：http://localhost:4000/posts/1036090074/1.jpg 图片大小的设置目前只能使用Hexo定义的asset_img标签设置:1&#123;% asset_img 1.jpg [width] [height] 我是图片 %&#125;]]></content>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搜索引擎优化(SEO)]]></title>
    <url>%2Fposts%2F58403%2F</url>
    <content type="text"><![CDATA[gitpage绑定域名-github版本 https://blog.csdn.net/linshuhe1/article/details/73013730 https://help.github.com/en/articles/using-a-custom-domain-with-github-pages gitpage绑定域名-coding版本 https://coding.net/help/doc/pages/domain.html SEO https://blog.csdn.net/sunshine940326/article/details/70936988]]></content>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>seo</tag>
        <tag>域名绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统调用IO]]></title>
    <url>%2Fposts%2F14179%2F</url>
    <content type="text"><![CDATA[参考 apue Low-Level Input/Output File System Interface 文件IO参考 apue第三章 fcntl.h 绝对路径和相对路径 文件描述符 apue 3.2 http://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html#Streams-and-File-Descriptors 文件描述符 文件描述符，file descriptor，简称fd。 When you want to do input or output to a file, you have a choice of two basic mechanisms for representing the connection between your program and the file: file descriptors and streams. File descriptors are represented as objects of type int, while streams are represented as FILE * objects. linux中两种机制去处理文件，fd(int类型) 和streams(FILE*类型)。fd跟windows的句柄、标准IO函数库的FILE都是一个作用，用于标识文件，通过它们进行文件操作。 在 UNIX 操作系统中，所有的外围设备(包括键盘和显示器)都被看作是文件系统中的文件。因此，这些设备的输入/输出其实都是通过文件读/写操作完成。另外，像socket、管道等的读取也可以看做是文件的读取。 fd和FILElinux系统调用的文件操作函数是用fd去操作的，如，read，write等函数。标准IO函数库的文件操作函数是用流（FILE）去操作的，如，fread，fwrite等函数。 可以通过fileno函数，获取FILE对象的fd值。 也可以通过fd值转换为FILE对象。 标准输入、标准输出、标准错误 对应的fd宏：STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO 对应的FILE宏：stdin、stdout、stderr 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * redirect.c * 如何理解stdin/stdout/stderr？ * 从文件的角度去理解stdin/stdout/stderr. * stdin/stdout/stderr的fd值其实是通过open函数打开某个设备文件而返回的，并且打开时指定为可读写.(设备也是其中一种文件类型) * 设备文件的路径可以查看/dev目录。 * fd = open("/dev/fd/0", O_RDWR);//标准输入打开的文件 * fd = open("/dev/fd/1", O_RDWR);//标准输出打开的文件 * fd = open("/dev/fd/2", O_RDWR);//标准错误输出打开的文件 * * 如何理解重定向？(可以使用strace观察执行过程) * 1. fd=0,1,2时,默认的输入源是键盘,默认的输出地是屏幕. * 2. 由于它们在open时被指定为可读写,所以他们都可以调用read和write函数,read的数据来自键盘,write的数据输出到屏幕. * 3. ./test/main.out &lt; a.txt &lt;符号改变fd等于0的输入源,read的源 * 4. ./test/main.out 1&gt; a.txt &gt;符号改变fd等于1的输出地,write的目的地 * 5. ./test/main.out 2&gt; a.txt &gt;符号改变fd等于2的输出地,write的目的地 * 6. ./test/main.out &lt;&gt; a.txt &lt;&gt;符号相当于&lt;和&gt;符合的组合效果 */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define BUFSIZE 4096int main()&#123; int n; char buf[BUFSIZE]; int fd; fd = STDIN_FILENO; // 标准输入, 状态标志等于：可读写(fcntl函数测试出来)// fd = STDOUT_FILENO; // 标准输出, 状态标志等于：可读写(fcntl函数测试出来)// fd = STDERR_FILENO; // 标准错误输出, 状态标志等于：可读写(fcntl函数测试出来) //读取 printf("请输入字符串:\n"); n = read(fd, buf, BUFSIZE); printf("读取%d字节\n", n); //写入 strcpy(buf, "hello world"); n = write(fd, buf, strlen(buf)); printf("\n写入%d字节\n", n); return 0;&#125; 函数open打开/创建文件。 open与openat的区别 http://www.bubuko.com/infodetail-2270848.html openat比open多了一个fd参数. 如果路径是绝对路径，fd参数可以忽略。 如果路径是相对路径，并且fd的值不等于AT_FDCWD，那么openat的相对路径参照的是fd的路径，否则，参照的是进程的当前工作目录。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define FILE_PATH_ABS "/mnt/hgfs/centos_share/LearnApue/files/a.txt" //绝对路径#define FILE_PATH "/mnt/hgfs/centos_share/LearnApue/" //文件路径#define FILE_PATH_REL "./files/a.txt" //相对路径int main()&#123; int fd1, fd2, fd3; //绝对路径// fd1 = open(FILE_PATH_ABS, O_RDONLY);// printf("%d\n", fd1);// fd2 = openat(fd1, FILE_PATH_ABS, O_RDONLY);// printf("%d\n", fd2); //相对路径 fd1 = open(FILE_PATH, O_RDONLY); printf("%d\n", fd1); fd2 = openat(fd1, FILE_PATH_REL, O_RDONLY); printf("%d\n", fd2); close(fd1); close(fd2); return 0;&#125; 函数lseek读取/修改文件偏移量。1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define FILE_PATH_REL "./files/a.txt" //相对路径int main()&#123; int fd; off_t offset; int whence; offset = 1;//偏移量 whence = SEEK_SET;//偏移等于文件开始位置+offset// whence = SEEK_CUR;//偏移等于当前值+offset,可用于读取文件当前的偏移值// whence = SEEK_END;//偏移等于文件结束位置+offset fd = open(FILE_PATH_REL, O_RDONLY); off_t offsetCur = lseek(fd, offset, whence); printf("%d\n", (int) offsetCur); if (offsetCur == -1) &#123; printf("%s\n", strerror((int) offsetCur)); &#125; close(fd); return 0;&#125; 函数read读取文件。1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define FILE_PATH_REL "./files/a.txt" //相对路径#define N 100int main()&#123; int fd; char buf[N]; size_t len = N;//读取100B fd = open(FILE_PATH_REL, O_RDONLY); ssize_t getLen; /** * read读取成功,返回读到的字节数 * 到达文件尾部,返回0 * 出错,返回-1 */ while ((getLen = read(fd, buf, len)) &gt; 0) &#123; printf("读取到%d个字节\n", (int) getLen); printf("读取到的字符串:%s\n", buf); &#125; close(fd); return 0;&#125; 函数write写入文件。1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define FILE_PATH_REL "../files/c.txt" //相对路径#define N 100int main()&#123; int fd; char buf[N]; fd = open(FILE_PATH_REL, O_CREAT | O_WRONLY | O_APPEND);//文件不存在则创建、可写、写入到文件尾部 strcpy(buf, "i am a test"); /** * 写入成功返回值等于调用时设置的写入数,否则就是写入错误. * 写入出错常见的原因为磁盘已满. * 写入时，如果指定的自字数比写入的字符串长度要大，则会写入一堆乱码字符. */ int writeLen = strlen(buf); int len = write(fd, buf, writeLen); if (len != writeLen) &#123; printf("写入失败\n"); &#125; else &#123; printf("实际写入%d字节(bytes)\n", (int) len); &#125; close(fd); return 0;&#125; 原子操作文件不存在，则创建文件执行动作： 123456789101112131415161718/** * apue-3.11 */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define FILE_PATH_REL "../files/f.txt" //相对路径int main()&#123; int fd; // 文件存在,报错,返回-1 // 文件不存在,创建文件,返回文件的fd fd = open(FILE_PATH_REL, O_CREAT | O_EXCL | O_RDONLY); printf("fd = %d\n", fd); return 0;&#125; 定位偏移量，然后读取文件(相当于lseek+read的原子操作)12345678910111213141516171819202122232425/** * apue-3.11 */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define FILE_PATH_REL "../files/a.txt" //相对路径#define N 100int main()&#123; int fd; char buf[N]; int offset = 0;//偏移量 fd = open(FILE_PATH_REL, O_RDWR); int getLen = pread(fd, buf, N, offset); printf("读取到%d个字节\n", (int) getLen); printf("读取到的字符串:%s\n", buf); return 0;&#125; 定位偏移量，然后写入文件(相当于lseek+write的原子操作)1234567891011121314151617181920212223242526/** * apue-3.11 */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define FILE_PATH_REL "../files/a.txt" //相对路径#define N 100int main()&#123; int fd; char buf[N]; int offset = 0;//偏移量 strcpy(buf, "i am jason"); fd = open(FILE_PATH_REL, O_RDWR); int getLen = pwrite(fd, buf, strlen(buf), offset); printf("写入%d个字节\n", (int) getLen); return 0;&#125; 函数dup和dup2复制现有的文件描述符。1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define FILE_PATH_REL "../files/a.txt" //相对路径int main()&#123; int fd, fd2; int result; fd = open(FILE_PATH_REL, O_RDWR); printf("fd=%d\n", fd); result = dup(fd); // 复制fd,返回当前可用fd的最小值. printf("dup,fd=%d\n", result); fd2 = 5; result = dup2(fd, fd2); // 复制fd,并指定复制后的fd值. printf("dup,fd=%d\n", result); return 0;&#125; 函数fcntl多功能函数。 复制fd。 获取/设置fd标志。 获取/设置文件状态标志。 获取/设置记录锁。 获取和设置文件状态标志。 12345678910111213141516171819202122232425&gt; /**&gt; * 设置文件状态标志(open文件时设置的标志)&gt; */&gt; #include "apue.h"&gt; #include &lt;fcntl.h&gt;&gt; &gt; #define FILE_PATH_REL "../files/a.txt" //相对路径&gt; &gt; int main()&gt; &#123;&gt; int fd;&gt; int val;&gt; &gt; fd = open(FILE_PATH_REL, O_RDONLY);&gt; &gt; if ((val = fcntl(fd, F_GETFL)) &lt; 0)//获取文件状态标志(F_GETFL)&gt; err_sys("fcntl F_GETFL error");&gt; &gt; val |= O_WRONLY;//添加状态标志&gt; &gt; if (fcntl(fd, F_SETFL, val) &lt; 0)//设置文件状态标志(F_SETFL)&gt; err_sys("fcntl F_SETFL error");&gt; printf("当前状态标志值=%d\n", val);&gt; &#125;&gt; 总结 这些函数操作出错，总是返回-1。 这些操作都属于内核操作，低级的IO操作。 这些操作可以操作所有的文件类型。如：普通文件、目录、Socket、设备文件。 函数或头文件名带有ctl单词的全称都是control。 系统调用IO和标准IO区别中提到的缓冲区跟系统调用函数sync提到的缓冲区有什么不一样？ 见：标准IO缓存区的讨论。 文件状态标志指的是open函数时指定的标志(只读、只写、读写等标志)。 文件操作参考 apue第四章 函数stat、fstat、fstatat、lstat获取文件的各种信息。 函数stat、fstat、fstatat、lstat 123456789101112131415161718192021222324252627282930&gt; #include &lt;stdio.h&gt;&gt; #include &lt;string.h&gt;&gt; #include &lt;stdlib.h&gt;&gt; #include &lt;errno.h&gt;&gt; #include &lt;unistd.h&gt;&gt; #include &lt;fcntl.h&gt;&gt; #include &lt;sys/stat.h&gt;&gt; &gt; int main()&gt; &#123;&gt; int fd;&gt; struct stat *buf;&gt; char *filePath = "../files/a.txt";&gt; int result;&gt; &gt; // fd = open(filePath, O_RDONLY);&gt; // 函数stat,返回文件的信息结构.类似于执行命令ls、stat.&gt; // 函数lstat,类似于stat,但当文件是符号链接时,lstat返回该符号链接的信息,而不是符号链接引用的文件信息&gt; // 函数fstat&gt; // 函数fstatat&gt; result = stat(filePath, buf);&gt; if (result == -1) &#123;&gt; printf("%s\n", strerror(errno));&gt; exit(1);&gt; &#125;&gt; printf("uid=%d\n", buf-&gt;st_uid);&gt; &gt; return 0;&gt; &#125;&gt; struct stat记录文件信息的结构体。 stat结构的信息大多取自于inode的信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&gt; #include &lt;stdio.h&gt;&gt; #include &lt;string.h&gt;&gt; #include &lt;stdlib.h&gt;&gt; #include &lt;errno.h&gt;&gt; #include &lt;unistd.h&gt;&gt; #include &lt;fcntl.h&gt;&gt; #include &lt;sys/stat.h&gt;&gt; &gt; //struct stat &#123;&gt; // dev_t st_dev; /* ID of device containing file */&gt; // ino_t st_ino; /* Inode number */&gt; // mode_t st_mode; /* File type and mode */ /*文件类型和模式(如：文件访问权限)*/&gt; // nlink_t st_nlink; /* Number of hard links */&gt; // uid_t st_uid; /* User ID of owner */&gt; // gid_t st_gid; /* Group ID of owner */&gt; // dev_t st_rdev; /* Device ID (if special file) */&gt; // off_t st_size; /* Total size, in bytes */ /*文件实际大小*/&gt; // blksize_t st_blksize; /* Block size for filesystem I/O */ /*block的实际大小*/&gt; // blkcnt_t st_blocks; /* Number of 512B blocks allocated */ /*bolck的块数(当block等于512B时,block的块数) /&gt; //&gt; // /* Since Linux 2.6, the kernel supports nanosecond&gt; // precision for the following timestamp fields.&gt; // For the details before Linux 2.6, see NOTES. */&gt; //&gt; // struct timespec st_atim; /* Time of last access */ /*访问时间*/&gt; // struct timespec st_mtim; /* Time of last modification */ /*修改时间*/&gt; // struct timespec st_ctim; /* Time of last status change */ /*状态时间*/&gt; //&gt; //#define st_atime st_atim.tv_sec /* Backward compatibility */&gt; //#define st_mtime st_mtim.tv_sec&gt; //#define st_ctime st_ctim.tv_sec&gt; //&#125;;&gt; &gt; int main()&gt; &#123;&gt; struct stat *buf;&gt; char *filePath = "../files/a.txt";&gt; int result;&gt; &gt; result = stat(filePath, buf);&gt; if (result == -1) &#123;&gt; printf("%s\n", strerror(errno));&gt; exit(1);&gt; &#125;&gt; &gt; //执行stat命令也可以看到这些数据&gt; printf("uid=%d\n", buf-&gt;st_uid);&gt; printf("gid=%d\n", buf-&gt;st_gid);&gt; printf("file type and mode=%d\n", buf-&gt;st_mode);&gt; printf("文件实际大小=%dB\n", buf-&gt;st_size);&gt; printf("block的块数(当block等于512B时,block的块数)=%d\n", buf-&gt;st_blocks); // 512B的block块数等于8,那么它占用磁盘的大小等于512B*8=4096B=4K&gt; printf("block的实际大小=%dB\n", buf-&gt;st_blksize); // 在虚拟机共享文件的block size值是有点问题的&gt; &gt; printf("访问时间=%d\n", buf-&gt;st_atim.tv_sec); // 访问时间,秒部分&gt; printf("访问时间=%d\n", buf-&gt;st_atim.tv_nsec); // 访问时间,纳秒部分&gt; &gt; printf("修改时间=%d\n", buf-&gt;st_mtim.tv_sec); // 修改时间,秒部分&gt; printf("修改时间=%d\n", buf-&gt;st_mtim.tv_nsec); // 修改时间,纳秒部分&gt; &gt; printf("状态改变时间=%d\n", buf-&gt;st_ctim.tv_sec); // 状态改变时间,秒部分&gt; printf("状态改变时间=%d\n", buf-&gt;st_ctim.tv_nsec); // 状态改变时间,纳秒部分&gt; &gt; return 0;&gt; &#125;&gt; 获取文件类型1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 获取文件类型 * 测试命令： * find / -type b * find / -type c * find / -type s * find / -type p * find / -type l * ./4-3-filetype.out /etc/passwd /etc /dev/log /dev/tty /run/systemd/initctl/fifo /dev/sr0 /dev/cdrom */#include "apue.h"int main(int argc, char *argv[])&#123; int i; struct stat buf; char *ptr; for (i = 1; i &lt; argc; i++) &#123; printf("%s: ", argv[i]); if (lstat(argv[i], &amp;buf) &lt; 0) &#123; err_ret("lstat error"); continue; &#125; if (S_ISREG(buf.st_mode)) ptr = "regular"; else if (S_ISDIR(buf.st_mode)) ptr = "directory"; else if (S_ISCHR(buf.st_mode)) ptr = "character special"; else if (S_ISBLK(buf.st_mode)) ptr = "block special"; else if (S_ISFIFO(buf.st_mode)) ptr = "fifo"; else if (S_ISLNK(buf.st_mode)) ptr = "symbolic link"; else if (S_ISSOCK(buf.st_mode)) ptr = "socket"; else ptr = "** unknown mode **"; printf("%s\n", ptr); &#125; exit(0);&#125; 函数access和faccessat检查实际uid是否拥有文件访问权限。 正常情况下，有效uid等于实际uid。但是通过suid机制可以改变有效uid从而改变文件访问权限。如果依然想检查实际uid是否拥有文件访问权限，就可以使用此类函数。如：某个用户jasonzhi虽然可以通过suid机制使用root用户权限访问到/etc/shadow文件，但是其实际uid依然等于jasonzhi。当调用access函数时，就会返回其实际uid没有权限访问/etc/shadow文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243&gt; /**&gt; * 测试命令：&gt; * su - root&gt; * mv 4-8-access.out /home # 不能在共享目录执行,否则测试出结果&gt; * ll -d /home/4-8-access.out&gt; * chown 0777 /home/4-8-access.out&gt; *&gt; * su - jasonzhi&gt; * echo "abc" &gt; /usr/local/src/a.txt&gt; * /home/4-8-access.out /usr/local/src/a.txt # access通过,open通过&gt; * /home/4-8-access.out /etc/shadow # access不通过,open不通过&gt; *&gt; * su - root&gt; * chmod u+s /home/4-8-access.out&gt; * su - jasonzhi&gt; * /home/4-8-access.out /etc/shadow # access不通过,open通过&gt; */&gt; #include "apue.h"&gt; #include &lt;fcntl.h&gt;&gt; &gt; int main(int argc, char *argv[])&gt; &#123;&gt; if (argc != 2)&gt; err_quit("usage: /home/4-8-access.out &lt;pathname&gt;");&gt; if (access(argv[1], R_OK) &lt; 0)&gt; err_ret("access error for %s", argv[1]);&gt; else&gt; printf("read access OK\n");&gt; &gt; int fd;&gt; if ((fd = open(argv[1], O_RDONLY)) &lt; 0)&gt; err_ret("open error for %s", argv[1]);&gt; else &#123;&gt; printf("open for reading OK\n");&gt; &gt; //读文件&gt; char buf[4096];&gt; read(fd, buf, 4096);&gt; printf("content=%s\n", buf);&gt; &#125;&gt; exit(0);&gt; &#125;&gt; 函数link、linkat、unlink、unlinkat和remove 函数link、linkat 创建硬/软链接。 函数unlink、unlinkat 删除硬/软链接 or 删除文件(当硬链接数等于0时)。 函数remove ，对于文件，与unlink功能相同。对于目录，与rmdir功能相同。 link的使用 1234567891011121314151617181920212223242526272829303132&gt; /**&gt; * 创建硬链接&gt; * 不能在虚拟机共享目录测试&gt; * 测试命令：&gt; * ll -i /home&gt; * echo "abc" &gt; /home/a.txt&gt; * ./main.out&gt; */&gt; #include &lt;stdio.h&gt;&gt; #include &lt;string.h&gt;&gt; #include &lt;stdlib.h&gt;&gt; #include &lt;errno.h&gt;&gt; #include &lt;unistd.h&gt;&gt; #include &lt;fcntl.h&gt;&gt; &gt; int main()&gt; &#123;&gt; char *existPath = "/home/a.txt";&gt; char *newPath = "/home/hard_link.txt";&gt; int result;&gt; &gt; result = link(existPath, newPath);// 相当于执行命令：ln /home/a.txt /home/hard_link.txt&gt; if (result == -1) &#123;&gt; printf("error:%s\n", strerror(errno));&gt; exit(1);&gt; &#125;&gt; &gt; printf("success,%d\n", result);&gt; &gt; return 0;&gt; &#125;&gt; 函数symlink、symlinkat、readlink、readlinkat 函数symlink、symlinkat 创建符号链接。 符号链接、软链接是一个意思。 函数readlink、readlinkat 读取符号链接。 open函数是跟随符号链接的(打开的是符号链接引用的文件)，如果需要打开链接本身，就需要这两个函数。 这两个函数组合了open、read、close的所有操作。 symlink的使用 1234567891011121314151617181920212223242526272829303132&gt; /**&gt; * 创建软链接&gt; * 不能在虚拟机共享目录测试&gt; * 测试命令：&gt; * ll -i /home&gt; * echo "abc" &gt; /home/a.txt&gt; * ./main.out&gt; */&gt; #include &lt;stdio.h&gt;&gt; #include &lt;string.h&gt;&gt; #include &lt;stdlib.h&gt;&gt; #include &lt;errno.h&gt;&gt; #include &lt;unistd.h&gt;&gt; #include &lt;fcntl.h&gt;&gt; &gt; int main()&gt; &#123;&gt; char *actualPath = "/home/a.txt"; // 指向的文件名&gt; char *sympathPath = "/home/symbolic_link.txt"; // 符号链接名&gt; int result;&gt; &gt; result = symlink(actualPath, sympathPath);// 相当于执行命令：ln -s /home/a.txt /home/symbolic_link.txt&gt; if (result == -1) &#123;&gt; printf("error:%s\n", strerror(errno));&gt; exit(1);&gt; &#125;&gt; &gt; printf("success,%d\n", result);&gt; &gt; return 0;&gt; &#125;&gt; readlink的使用 12345678910111213141516171819202122232425262728293031&gt; /**&gt; * 读取软链接&gt; */&gt; #include &lt;stdio.h&gt;&gt; #include &lt;string.h&gt;&gt; #include &lt;stdlib.h&gt;&gt; #include &lt;errno.h&gt;&gt; #include &lt;unistd.h&gt;&gt; #include &lt;fcntl.h&gt;&gt; &gt; #define N 100&gt; &gt; int main()&gt; &#123;&gt; int len;&gt; char buf[N];&gt; char *sympathPath = "/home/symbolic_link.txt"; // 符号链接名&gt; &gt; memset(buf, '\0', sizeof(buf));// readlink读取到的字符串是没有结束符合的,所以需要初始化buf数组&gt; len = readlink(sympathPath, buf, N);//相当于执行命令：readlink /home/symbolic_link.txt&gt; if (len == -1) &#123;&gt; printf("error:%s\n", strerror(errno));&gt; exit(1);&gt; &#125;&gt; &gt; printf("len=%d\n", len);&gt; printf("content=%s\n", buf);&gt; &gt; return 0;&gt; &#125;&gt; 总结 AT_FDCWD参数用于名字带有at后缀的函数。当路径为相对路径时，并指定AT_FDCWD，那么相对路径是相对于工作目录。否则，相对于fd参数的路径。如：openat、faccessat、readlinkat函数。 文件访问权限指的是文件的s、r、w、x权限。 目录操作参考 apue第四章 dirent.h 目录访问 函数mkdir、mkdirat、rmdir mkdir、mkdirat 创建目录。 rmdir 删除空目录。 函数opendir、readdir opendir 打开目录。返回DIR类型变量，用于操作目录。 readdir 读取目录。读取某个目录下的所有内容。目录中的每一项使用struct dirent表示。 opendir+readdir 1234567891011121314151617&gt; #include &lt;stdio.h&gt;&gt; #include "apue.h"&gt; #include &lt;dirent.h&gt;&gt; #include &lt;sys/types.h&gt;&gt; &gt; int main()&gt; &#123;&gt; //打开当前目录,DIR代表打开的文件资源&gt; DIR *dir = opendir("./");&gt; struct dirent *sd;&gt; //读取当前文件的所有文件&gt; while ((sd = readdir(dir)) != NULL) &#123;&gt; printf("文件名为：%s\n", sd-&gt;d_name);&gt; &#125;&gt; return 0;&gt; &#125;&gt; struct direntstruct dirent struct dirent对应目录下的一个文件项(entry)，用于记录该项的信息。123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/types.h&gt;//struct dirent &#123;// ino_t d_ino; // inode 号码// off_t d_off; //// unsigned short d_reclen; // 记录的长度// unsigned char d_type; // 文件类型// char d_name[256]; // 文件名//&#125;int main()&#123; //打开当前目录,DIR代表打开的文件资源 DIR *dir = opendir("./"); struct dirent *sd; //读取当前文件的所有文件 while ((sd = readdir(dir)) != NULL) &#123; printf("Inode：%d\n", sd-&gt;d_ino); printf("文件名为：%s\n", sd-&gt;d_name); printf("文件类型为：%c\n", sd-&gt;d_type); printf("记录的长度:%d\n", sd-&gt;d_reclen); printf("=============================\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>低级IO</tag>
        <tag>底层IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号]]></title>
    <url>%2Fposts%2F29204%2F</url>
    <content type="text"><![CDATA[信号 http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#signal 鸟哥P522 man -f signal 信号涉及的多个文档，如：man 7 signal可以查看各个信号的含义。 apue 第10章 如果不设置信号处理函数，接收到信号后会执行默认行为。每种信号都会对应以下一种行为： 12345Term 默认行为是结束进程。 Ign 默认行为是忽略信号。 Core 默认行为是结束进程并生成core dump文件。Stop 默认行为是停止(暂停)进程。Cont 默认行为是如果进程处于停止状态，则继续运行进程。 信号类型： 1234567891011121314151617kill –l 查看系统支持的信号kill -l | grep "SIGTSTP"不同系统，同一信号名可能会对应不同的信号。Centos 7系统下：1 SIGHUP 行为：Term。2 SIGINT 行为：Term。从键盘输入的中断。相当于ctrl+c 3 SIGQUIT 行为：Core。从键盘输入的退出。相当于ctrl+\。6 SIGABRT 行为：Core。调用函数abort(3)会产生此信号。9 SIGKILL 行为：Term。结束进程。10 SIGUSR1 行为：Term。用户自定义信号1。12 SIGUSR2 行为：Term。用户自定义信号2。15 SIGTERM 行为：Term。结束进程。相对于SIGKILL，SIGKILL不能被捕捉或忽略。18 SIGCONT 行为：Cont。如果进程处于停止状态，则继续运行进程。19 SIGSTOP 行为：Stop。暂停进程。20 SIGTSTP 行为：Stop。从终端暂停进程。相当于ctrl+z 信号处理程序跟主程序属于同一个线程。当进程接收到信号后，线程会停下手中处理的事情，去处理信号处理程序的事情。等处理完后，继续执行捕捉到信号时正在处理的事情。因此： 当进程处于阻塞状态(如：调用函数read)，接收到信号后直接跳到信号处理程序。 当进程处于运行状态(如：运行100w次for循环)，接收到信号后直接跳到信号处理程序。 函数signalSigfunc *signal(int, Sigfunc *) 参数：(信号，信号处理函数) 返回值：若成功，返回上一次的信号处理函数，若出错，返回SIG_ERR。 12345678910//通过调用函数signal，获取信号当前的处理函数。 int main()&#123; //只有信号SIGINT,SIGQUIT当前未被忽略,才设置它们的处理函数 void sig_int(int), sig_quit(int); if (signal(SIGINT, SIG_IGN) != SIG_IGN) signal(SIGINT, sig_int); if (signal(SIGQUIT, SIG_IGN) != SIG_IGN) signal(SIGQUIT, sig_quit);&#125; 函数signal的使用例子： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;error.h&gt;static void sig_usr(int); /* one handler for both signals */int main(void)&#123; if (signal(SIGUSR1, sig_usr) == SIG_ERR) perror("can't catch SIGUSR1"); if (signal(SIGUSR2, sig_usr) == SIG_ERR) perror("can't catch SIGUSR2");// for (;;) &#123;//// &#125; for (;;) pause();&#125;static void sig_usr(int signo) /* argument is signal number */&#123; if (signo == SIGUSR1) printf("received SIGUSR1\n"); else if (signo == SIGUSR2) printf("received SIGUSR2\n"); else printf("received signal %d\n", signo);&#125; 命令trap https://wangchujiang.com/linux-command/c/trap.html 指定在接收到信号后将要采取的动作。 命令kill http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#kill 鸟哥P514、鸟哥P522 kill -&lt;信号数字|信号名&gt; &lt;pid&gt; 1234以下命令作用相同:kill -9 &lt;pid&gt;kill -SIGKILL &lt;pid&gt;kill -KILL &lt;pid&gt; 123应用：kill -9 &lt;pid&gt; 强制终止某个进程ps -ef | grep server.php | grep -v 'grep' | awk '&#123;print $2&#125;' | xargs kill -9` 批量删除进程 命令pkill向某个程序名发送信号。如：pkill -USR2 main.out 命令killall http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#killall鸟哥P522 kill -&lt;信号数字|信号名&gt; &lt;命令&gt; 如：12killall -9 nginx 终止用nginx命令启动的进程killall -9 php-fpm 终止用php-fpm命令启动的进程 参数-i 交互式。删除时有提示信息。-I(大写i)：忽略大小写。]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的使用]]></title>
    <url>%2Fposts%2F42749%2F</url>
    <content type="text"><![CDATA[参考 官网 github 官方文档(中文版本落后于英文版本) Easy Hexo bilibili 教程 node.js 教程 yaml hexo的当前版本信息hexo version1234567891011121314151617$ hexo versionhexo-cli: 1.1.0os: Windows_NT 10.0.14393 win32 x64http_parser: 2.8.0node: 10.15.2v8: 6.8.275.32-node.12uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e hexo目录结构说明 scaffolds 存放文章的母版(模板)文件 _config.yml 项目配置文件 hexo命令12345678910111213141516171819202122帮助:hexo helphexo generate -hhexo version 查看hexo版本hexo init blog 初始化bloghexo clean 清除所有自动生成的文件hexo generate(g) 生成静态文件hexo server(s) 创建服务器hexo server --config custom.ymlhexo server --config custom.yml,custom2.ymlhexo new "文章名" 创建文章,layout分为: post,page,drafthexo list post 列出文章hexo list route 列出目录hexo generate --cwd /path 设置当前工作目录hexo deploy 部署网站hexo clean &amp;&amp; hexo g -d 一键发布 插件 https://hexo.io/plugins/ 相关命令：npm list hexo-deployer-git列出已安装的插件npm install hexo-generator-search --save安装插件 插件收藏：hexo-abbrlink(为文章生成唯一id)hexo-admin(hexo管理后台) 主题 https://hexo.io/themes/ 常用主题：landscape（默认主题）next(据说很多人都用)BlueLake(功能挺多的，有左侧目录) Next主题 github-中文文档 使用手册 Next插件 网站参考 其他配置参考 其他配置参考 主题安装git clone https://github.com/theme-next/hexo-theme-next themes/next Next项目说明 默认使用的模板引擎使用swig 测试的时候有一个坑，测试时localhost使用的是http，而正式发布使用的是https，会造成测试和正式的情况不一样的假象。 使用Next的版本库时需要注意： 使用自定义的主题配置文件 使用git子项目管理Next版本库 自定义主题配置文件https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/DATA-FILES.md hexo编辑器 https://github.com/zhuzhuyule/HexoEditor https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md https://github.com/Moeditor/Moeditor 分配标签、分类tab的index页面12hexo new page &apos;tags&apos; # 创建tags子目录,在index.md文件中添加type: &quot;tags&quot;hexo new page &apos;categories&apos; # 创建categories子目录,在index.md文件中添加type: &quot;categories&quot; 配置新的tab并归类到分类1234567修改./next/_config.yml的menu选项.加入以下内容:apues: /categories/系统编程/ || linux修改./next/languages/zh-CN.yml的menu选项.加入以下内容:apues: 系统编程 设置背景图https://blog.csdn.net/mango_haoming/article/details/78473243123456789修改文件：themes\next\source\css\_custom\custom.styl添加内容// 更改背景图body &#123; //background:url(https://source.unsplash.com/random/1900x900); background:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%;&#125; 背景图动态效果(canvas)https://github.com/theme-next/theme-next-canvas-nest 修改底部标签样式12修改themes\next\layout\_macro\post.swig文件，搜索rel=&quot;tag&quot;&gt;#，将#替换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;。 文章置顶 https://blog.csdn.net/qwerty200696/article/details/79010629 https://github.com/netcan/hexo-generator-index-pin-top123456789101. 执行命令：npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save # 文章置顶2. 需要置顶的文章的Front-matter中加上top: true3. 修改blog/themes/next/layout/_macro/post.swig文件，定位到&lt;div class=&quot;post-meta&quot;&gt;插入如下内容：&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 搜索 https://github.com/theme-next/hexo-generator-searchdb (本地查找(next基于插件:hexo-generator-search进行开发)) https://github.com/theme-next/theme-next-algolia-instant-search(查找服务) 加载进度条(展示在顶部)https://github.com/theme-next/theme-next-pace 展示文章字数和阅读时长https://github.com/theme-next/hexo-symbols-count-time 修改next的配置没有生效，需要修改项目的配置才有效 第三方服务设置https://blog.junyu.io/posts/0005-next-theme-settings.html#blogrolls 网站统计 百度统计 文章阅读量显示leancloud： https://github.com/theme-next/hexo-leancloud-counter-security https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md https://yunhao.space/2018/06/27/hexo-leancloud-plugin-installation-tutor/ 网站访客量http://ibruce.info/2015/04/04/busuanzi 文章评论功能 参考 Valine Gitment Valine 官网 配置参考12345671. 安装npm模块npm install leancloud-storage --savenpm install valine --save2. 配置LeanCloud,获取appid和appkey3. 配置LeanCloud,创建Comment Class4. 配置主题配置文件,配置项为：valine5. hexo clean &amp;&amp; hexo g -d &amp;&amp; hexo s _config.yml的其他配置项说明 auto_excerpt 首页文章自动摘要，或者使用标签： social 修改社交信息，如：github、email地址]]></content>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的使用]]></title>
    <url>%2Fposts%2F45630%2F</url>
    <content type="text"><![CDATA[参考Markdown语法 https://coding.net/help/doc/project/markdown.html Markdown官网文档 github的语法 Word文档转Markdown pandoc 在线直接转换 Markdown编写工具 typora Editor.md 在线编辑器 Yu Writer MarkdownPad 其他参考 其他参考 目前选用的编辑器是typora，支持文章大概，界面简洁，优秀的即视效果，跨平台，免费。个人认为目前最好的Markdown编辑器,不接受任何一起反驳。 Markdown语法文本换行每行后面加两个空格 代码 按tab键然后输入即可 放在行内代码字符之间 见下. 1代码块 1代码块，部分markdown编辑器不生效 H1标题H2标题H3标题加粗斜体 引用 超链接 分割线 有序列表 有序列表 无序列表 无序列表 插入时间戳2017-6-9 9:51:35 时间戳格式：yyyy-M-d H:mm:ss 网络图片 内部图片 把图片通过base64存入markdown文件 markdown 的空格，空行，换行符 标题上下的空行无意义，一般上下各空一行。 分隔符上下的空行无意义，一般上下各空一行。 引用上下的空行无意义，一般上下各空一行 普通文字的上下空行是有意义的，会影响整体格式。 普通文字要换行，需要在最后加上两个空格。按enter键的换行只有部分markdown引擎才能识别。或者使用&lt;br&gt;进行换行 单词之间的多个空格。只有在代码块中才有意义，其他标签都无意义。 插入空格可以使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1111]]></content>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
